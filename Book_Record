1
验证邮件地址：
模式=LocalName@DomainPrefix.DomainSuffix
匹配的正则表达式：  /^\w+@\w+/.\w{2,3}$/
但是邮件地址比它给人的第一眼印象更为复杂。为数据验证构筑可靠的邮件模式时，其实还要考虑几种基础邮件格式的变化版。
1.用户名称部分包含下划线、连字符 i-lovecube_lovers@youcube.ca
2.用户名称部分包含点号、加号tor.howard+jason@bannerocity.com
3.域名的prefix部分包含连字符 rocky@i-rock.mobi
4.域名的suffix部分包含4个字符 rocky@i-rock.mobi  
5.多一个域suffix，他只是域名的额外部分 ruby@youcube.com.nz
邮件地址呈现了模式中需要匹配可选性字符的需求   从集合中匹配可选字符
{在正则表达式里具有特殊意义的字符需要经过转义，才能把实际字符放在正则表达式里。下列字符前均需加上反斜线（\)做转义：
[ \ ^ $ . | ? * + () }
模式= LocalName@DomainPrefix.DomainSuffix
第一部分： 任何字母数字加上“ . ” “ — ” “ _  ” “ + ”
第二部分： 任何字母数字加上“ — ”
第三部分： 点号被视为域名Suffix的一部分
第四部分： 任何2,3,4个字符的字母数字，前接点号。
/^[\w\.—_\+]+@[\w—]+(\.\w{2,4})+$/

2
当变量和函数被放在对象里，他们都被当成对象成员。更详细地说，变量称为对象的特性，函数则称为对象的方法。
对象是一组有名称的特性与方法的集合。对象是一种数据类型。
类，是对象的描述；实例，则是实际对象，从类中创建。对象类是种模板，对象实例则是根据模板创建的事物。
关键字this用于设置实例拥有的特性和方法。
有种实例方法直接为类所有，这表示该方法只有一份，由所有实例共享。类拥有的实例方法。方法存储在类里，让所有实例共享一份方法代码。当方法为类所拥有时，
所有该类的实例都可访问方法，因此不需要另外复制一份。在类层，使用prototype设定隶属于类层的特性与方法，而非属于实例的。
构造函数现在只需专注于特性的创建和初始化，因为方法并未指派给特定Blog实例，指派行动即发生在构造函数外。每个方法均于prototype对象里设置，而非于
Blog()构造函数里使用关键字this。
类特性在类里存储一次，但能被所有实例访问。
每个对象都有个prototype对象，它允许在类层增加特性和方法。任何对象，甚至包括Javascript标准对象。
类方法——为类所有但无法访问实例特性的方法，不过可以访问类特性。
类方法的创建，是为类设定方法，但不使用prototype对象——仅使用类名和对象符号（点号）把方法指派给类。为了从类方法里访问类特性，你必须下探至prototype特性。

3
引用只能指向指称目标，不能指向另一个引用。
var items = ['one', 'two', 'three'];
var itemRef = items;
items = ['new', 'array'];
//items和itemsRef现在指向不同的对象
console.log(items !== itemsRef);

修改对象生成一个全新对象，而非自修改对象。
字符串尤其令人不解，它的运作方式类似于对象，但是同函数或变量一起使用时，字符串却又是实实在在的原始值。

当变量没有明确声明（使用 var）作用域时，他会被定义成全局作用域，即使他只是打算在函数中使用。

call方法使用第一个参数来指定上下文，

4 成员可见性
Javascript只有两种作用域：全局作用域和当前执行函数的作用域。闭包是实现对私有成员进行特权访问的关键。他的工作原理是这样：在用于构造对象的函数内部使用
var创建私有成员。(至于这些私有成员到底是函数还是属性，这就由你来决定)在该作用域中创建一个函数，他肯定可以访问到私有数据——两者都处于相同的作用域中。
将这个新函数加入对象中，并将其(私有数据除外)设置为公共属性。该函数和数据都源自同一个作用域，因此可以间接访问数据。代码如下：
var Person = {
	firstName : 'john',
	lastName : 'Shen',
	birthDate : new Date('1997-02-12'),
	gender : 'male',
	getAge : function() {
		var today = new Date();
		var diff = today.getTime()-this.birthDate.getTime();
		var year = 365.25*24*60*60*1000;
		return Math.floor( diff/year );
	},
	toString : function() {
		return this.firstName + ' ' + this.lastName + ' is a ' + this.getAge() + ' years-old ' + this.gender;
	},
	extend : function( config ) {
		var temp = Object.create( this );
		console.log( temp.toString() );
		for( var key in config ) {
			if( config.hasOwnProperty( key ) ) {
				temp[key] = config[ key ];
			}
		}

	var creationTime = new Date();
	var getCreationTime = function() {
		return creationTime;
	}
	temp.getCreationTime = getCreationTime;
	return temp;
	}
};

var Teacher = Person.extend( {
	job : 'teacher',
	subject : 'English literature',
	yearsExp : 5,
	toString : function() {
		var originalStr = Person.toString.call( this );
		return originalStr + ' ' + this.subject + ' teacher. ';
	}
} );
var patty = Teacher.extend( {
	firstName : 'karlie',
	lastName : 'Selina',
	subject : 'chemistry',
	yearsExp : 20,
	gender : 'female'
} );
console.log( patty.toString() );
console.log( 'The Teacher object was created at %s', patty.getCreationTime() );
creationTime作为函数extend()的局部变量，在函数外部是不可用的。在控制台使用console.dir查看Person，你会发现creationTime并非Person的公共属性。
getCreationTime最初也是这样。利用一个简单的赋值，我们将getCreationTime()安放在所返回的对象实例中。现在，getCreationTime()成为了一个公共方法，
可以对creationTime中的私有数据进行特权访问。PS：考虑到内存问题，要谨慎使用特权方法，把他们留给需要严格控制访问的数据。

5 用于检索元素文本内容的通用函数
  function text(e) {
	var t = '' ;
	//如果传入的是一个元素，则获得其子元素；
        //否则认为传入的是一个数组
	e = e.childNodes || e;
	//查找所有的子节点
	for ( var j=0; j<e.length; j++ ) {
		t += e[j].nodeType != 1 ?
		e[j].nodeValue : text(e[j].childNodes);
	}
	//返回获得的文本
	return t;
}
//获取<p>元素的文本内容
var pElem = document.getElementsByTagName ( 'p' );
console.log( text( pElem ) );

6 元素属性值的获取和设置
function attr(elem, name, value) {
	//确保所提供的名称合法
	if( !name || name.constructor != String ) return '';
	//是否需要更改名称
	name = { 'for': 'htmlFor', 'className': 'class' }[name] || name;
	//如果需要设置特性值
	if( typeof value != 'undefined' ) {
		//先使用最快的设置方式
		elem[name] = value;
		//如果可以的话，使用setAttribute
		if ( elem.setAttribute )
			elem.setAttribute(name, value);
	}
	//返回特性值
	return elem[name] || elem.getAttribute( name ) || '';			
}
//使用attr函数从DOM元素中设置及检索特性值
attr( document.getElementsByTagName( 'li' )[0], 'class', 'isme' );
var liattr = document.getElementById( 'everywhere' ).getAttribute( 'class' );
console.log( liattr ); //isme

7 术语定义的动态出发
//等待DOM准备完毕
document.addEventListener('DOMContentLoaded', addEventClickToTerms);

//看用户是否单击术语
function addEventClickToTerms() {
	var dt = document.getElementsByTagName( 'dt' );
	for( var i=0; i<dt.length; i++ ) {
		dt[i].addEventListener( 'click', checkIfOpen);
	}
}
//检查术语定义是否已经展开
//因为第一个兄弟节点是一个文本节点(供单击的文字)，所以需要使用两个nextSibling
//如果没有被单击，其样式应该为''。如果被单击，样式则为'none',因此需要在if语句中检查这两种情况
function checkIfOpen(e) {
	if( e.target.nextSibling.nextSibling.style.display == '' || e.target.nextSibling.nextSibling.style.display == 'none' ) {
		e.target.nextSibling.nextSibling.style.display = 'block';
	}else{
		e.target.nextSibling.nextSibling.style.display = 'none';
	}
}

8 创建新DOM元素的通用函数
function create( elem ) {
	return document.createElementNS ?
	       document.createElementNS( 'http://www.ws.org/1999/xhtml', elem ) :
		   document.createElement( elem );
}
var div = create( 'div' );
div.className = 'items';
div.id = 'all';

9 一个可以在另一个函数之前插入元素的函数
function addElement() {
	//获取文档中的有序列表
	//记住getElementById会返回一个类似对象的数组	
	var orderList = document.getElementById( 'myList' );
	//创建<h1>，增加一个文本节点，并将其追加到<h1>之后
	var h = document.createElement( 'h1');
	    h.appendChild( document.createTextNode( 'Thanks for visiting' ));
	orderList.insertBefore(h, orderList[0]);    //记忆参数的次序：要把第一个元素插入到第二个元素的前面
}







